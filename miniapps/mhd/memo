run:
exMHD -r 4 -o 2 -tf 3 -vs 100 -dt .0005

plot:
glvis -m refined.mesh -g current.sol -k "mmcRjl" -ww 800 -wh 800
glvis -m refined.mesh -g psiPer.sol -k "mmc" -ww 800 -wh 800

Issues:
x it has to assemble nv and nb each time step, not sure how to do it implicitly (am I doing matrix-free for those two? Probably not)

3/25
fix a bug from boundary condition when compute J=nable Psi (it did not consider boundary condition)

3/23
clean up the explicit code; move on to test AMR (explicit)

Should I remove nodes in the mesh (nodes only for ALE type methods??)?

AMR with explicit time stepping is not very clear
How to do subcyling?


good example on amr:
 ./ex6 -m ../data/fichera.mesh -o 2

3/22 
After fix the rhs boundary bug, OK for wave case
tearing mode looks ok so far

exMHD -r 4 -tf 250 -vs 200 -dt .001 -i 2
quick testing:
./exMHD -r 2 -tf 10 -vs 50 -dt .004 -i 2

3/21
o add visit

for o = 2
the solutions appear to be first order (from omega and phi); it looks okay
there is a boundary layer for omega

for o3 r4, the errors from boundary become very large; this is strange

Test:
exMHD -m ../xperiodic-square.mesh -r 2 -o 2 -tf 3 -vs 50 -dt .001 -visit
exMHD -m ../xperiodic-square.mesh -r 3 -o 2 -tf 3 -vs 100 -dt .0005 -visit

find a potential bug in the boundary: how could I impose dirichlet boundary in the right hand side?

redo those examples:
../exMHD -m ../xperiodic-square.mesh -r 2 -o 3 -tf 3 -vs 100 -dt .001 -visit
../exMHD -m ../xperiodic-square.mesh -r 3 -o 3 -tf 3 -vs 200 -dt .0005 -visit
../exMHD -m ../xperiodic-square.mesh -r 4 -o 3 -tf 3 -vs 400 -dt .00025 -visit


3/20
o fix a ploting issue for order>2
o fix the boundary orientation, I believe the normal has to be outward
o fix the time stepping
o add visual



3/19
the boundary seems working by using but I do not know why it works...

   const int dim=2;
   VectorArrayCoefficient force(dim);
   for (int i = 0; i < dim-1; i++)
   {
      force.Set(i, new ConstantCoefficient(0.0));
   }
   {
      Vector pull_force(fespace.GetMesh()->bdr_attributes.Max());
      pull_force = -1.0;
      force.Set(dim-1, new PWConstCoefficient(pull_force));
   }

   b.AddDomainIntegrator(new VectorBoundaryLFIntegrator(force));
   b.Assemble();

   K->FormLinearSystem(ess_tdof_list, psi, b, A, X, B);

   so I will subtract B from z.

>>>using this fix in the full code gives me errors associated with memory, I think I did something very crazy.

Tzanio sent me the working code. What is the difference between AddBdrFaceIntegrator and AddBoundaryIntegrator?


3/13
the explicit code is working, however (they are probably all related to the boundary)
the current is still not right,
the boundary condition is not right

note the boundary condition for current should be 0, which is wrong now
If I turned off background B/Phi, then the current solver is right!
Reason:
M*J=K*Psi; however J=0 along the boundary; K*Psi=Psi along the boundary which is inconsistent, I need subtract those off

Luis: if we can figure out how to do it matrix-free in the explicit scheme, we should be good for the implicit scheme. The only matrix that needs to assemble is the mass and stiffness matrix (once in the how solve)

Q:
what solvers for mass and stiffness matrices I am using?

2019/3/6
the stucture of explicit scheme seems clear
the linear parts seem ok
the nonlinear term requires some work:
1. for explicit scheme, it is okay: I need to update matrix inside time step (with proper assembling, I am still not sure about how to do it). both PDSolver and exMHD need some work.
2. for nonlinear problem, how could link nonlinear term properly??

2019/3/3
move back to MFEM

>>>plot solutions at each time step (see ex16)
first open a glvis as a server in another terminal
then run the program; it should plot results auto

11/1
some useful info for developer:
https://github.com/mfem/mfem/blob/master/CONTRIBUTING.md#code-overview

10/30/2018
I believe I could use FE solver by providing the right hand side in two updates

Then I could built right side separatedly
