// Copyright (c) 2010-2021, Lawrence Livermore National Security, LLC. Produced
// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
// LICENSE and NOTICE for details. LLNL-CODE-806117.
//
// This file is part of the MFEM library. For more information and source code
// availability visit https://mfem.org.
//
// MFEM is free software; you can redistribute it and/or modify it under the
// terms of the BSD-3 license. We welcome feedback and contributions, see file
// CONTRIBUTING.md for details.

#if Q1D < D1D
#  define M1D D1D
#else
#  define M1D Q1D
#endif
#define M2D (M1D*M1D)

#define DQ1D (D1D*Q1D)

#define D2D (D1D*D1D)
#define D3D (D1D*D1D*D1D)

#define Q2D (Q1D*Q1D)
#define Q3D (Q1D*Q1D*Q1D)

#define M2_ELEMENT_BATCH 32

#define QUAD_2D_ID(X, Y) (X + ((Y) * Q1D))
#define QUAD_3D_ID(X, Y, Z) (X + ((Y) * Q1D) + ((Z) * Q2D))

typedef double* DofToQuad_t @dim(Q1D, D1D);
typedef double* QuadToDof_t @dim(D1D, Q1D);

typedef double* DLocal2D_t @dim(D1D, D1D, NE);
typedef double* QLocal2D_t @dim(Q1D, Q1D, NE);

typedef double* DLocal3D_t @dim(D1D, D1D, D1D, NE);
typedef double* QLocal3D_t @dim(Q1D, Q1D, Q1D, NE);

typedef double* Jacobian2D_t @dim(Q2D, 2, 2, NE);
typedef double* Jacobian3D_t @dim(Q3D, 3, 3, NE);

typedef double* Coeff2D_t @dim(Q2D, NE);
typedef double* Coeff3D_t @dim(Q3D, NE);

typedef double* SymmOperator2D_t @dim(Q2D, 3, NE);
typedef double* SymmOperator3D_t @dim(Q3D, 6, NE);

@kernel void DiffusionSetup2D(const int NE,
                              @restrict const double *W,
                              @restrict const Jacobian2D_t J,
                              @restrict const Coeff2D_t C,
                              @restrict SymmOperator2D_t op,
                              const bool const_c) {
  for (int e = 0; e < NE; ++e; @outer) {
    for (int q = 0; q < Q2D; ++q; @inner) {
      const double J11 = J(q, 0, 0, e), J12 = J(q, 1, 0, e);
      const double J21 = J(q, 0, 1, e), J22 = J(q, 1, 1, e);
      const double coeff = const_c ? C(0,0) : C(q,e);
      const double c_detJ = W[q] * coeff / ((J11 * J22) - (J21 * J12));
      op(q, 0, e) =  c_detJ * (J21*J21 + J22*J22); // (1,1)
      op(q, 1, e) = -c_detJ * (J21*J11 + J22*J12); // (1,2), (2,1)
      op(q, 2, e) =  c_detJ * (J11*J11 + J12*J12); // (2,2)
    }
  }
}

@kernel void DiffusionSetup3D(const int NE,
                              @restrict const double *W,
                              @restrict const Jacobian3D_t J,
                              @restrict const Coeff3D_t C,
                              @restrict SymmOperator3D_t op,
                              const bool const_c) {
  for (int e = 0; e < NE; ++e; @outer) {
    for (int q = 0; q < Q3D; ++q; @inner) {
      const double J11 = J(q, 0, 0, e), J12 = J(q, 1, 0, e), J13 = J(q, 2, 0, e);
      const double J21 = J(q, 0, 1, e), J22 = J(q, 1, 1, e), J23 = J(q, 2, 1, e);
      const double J31 = J(q, 0, 2, e), J32 = J(q, 1, 2, e), J33 = J(q, 2, 2, e);

      const double detJ = ((J11 * J22 * J33) + (J12 * J23 * J31) + (J13 * J21 * J32) -
                           (J13 * J22 * J31) - (J12 * J21 * J33) - (J11 * J23 * J32));

      const double coeff = const_c ? C(0,0) : C(q,e);
      const double c_detJ = W[q] * coeff / detJ;

      // adj(J)
      const double A11 = (J22 * J33) - (J23 * J32);
      const double A12 = (J23 * J31) - (J21 * J33);
      const double A13 = (J21 * J32) - (J22 * J31);

      const double A21 = (J13 * J32) - (J12 * J33);
      const double A22 = (J11 * J33) - (J13 * J31);
      const double A23 = (J12 * J31) - (J11 * J32);

      const double A31 = (J12 * J23) - (J13 * J22);
      const double A32 = (J13 * J21) - (J11 * J23);
      const double A33 = (J11 * J22) - (J12 * J21);

      // adj(J)^Tadj(J)
      op(q, 0, e) = c_detJ * (A11*A11 + A21*A21 + A31*A31); // (1,1)
      op(q, 1, e) = c_detJ * (A11*A12 + A21*A22 + A31*A32); // (1,2), (2,1)
      op(q, 2, e) = c_detJ * (A11*A13 + A21*A23 + A31*A33); // (1,3), (3,1)
      op(q, 3, e) = c_detJ * (A12*A12 + A22*A22 + A32*A32); // (2,2)
      op(q, 4, e) = c_detJ * (A12*A13 + A22*A23 + A32*A33); // (2,3), (3,2)
      op(q, 5, e) = c_detJ * (A13*A13 + A23*A23 + A33*A33); // (3,3)
    }
  }
}

@kernel void DiffusionApply2D_CPU(const int NE,
                                  @restrict const DofToQuad_t B,
                                  @restrict const DofToQuad_t G,
                                  @restrict const QuadToDof_t Bt,
                                  @restrict const QuadToDof_t Gt,
                                  @restrict const SymmOperator2D_t op,
                                  @restrict const DLocal2D_t X,
                                  @restrict DLocal2D_t Y) {
  // Iterate over elements
  for (int e = 0; e < NE; ++e; @outer) {
    for (int dummy = 0; dummy < 1; ++dummy; @inner) {
      double grad[Q1D][Q1D][2];
      for (int qy = 0; qy < Q1D; ++qy) {
	for (int qx = 0; qx < Q1D; ++qx) {
	  grad[qy][qx][0] = 0;
	  grad[qy][qx][1] = 0;
	}
      }

      for (int dy = 0; dy < D1D; ++dy) {
	double gradX[Q1D][2];
	for (int qx = 0; qx < Q1D; ++qx) {
	  gradX[qx][0] = 0;
	  gradX[qx][1] = 0;
	}

	for (int dx = 0; dx < D1D; ++dx) {
	  const double s = X(dx, dy, e);
	  for (int qx = 0; qx < Q1D; ++qx) {
	    gradX[qx][0] += s * B(qx, dx);
	    gradX[qx][1] += s * G(qx, dx);
	  }
	}

	for (int qy = 0; qy < Q1D; ++qy) {
	  const double wy  = B(qy, dy);
	  const double wDy = G(qy, dy);
	  for (int qx = 0; qx < Q1D; ++qx) {
	    grad[qy][qx][0] += gradX[qx][1] * wy;
	    grad[qy][qx][1] += gradX[qx][0] * wDy;
	  }
	}
      }

      // Calculate Dxy, xDy in plane
      for (int qy = 0; qy < Q1D; ++qy) {
	for (int qx = 0; qx < Q1D; ++qx) {
	  const int q = QUAD_2D_ID(qx, qy);
	  const double O11 = op(q, 0, e);
	  const double O12 = op(q, 1, e);
	  const double O22 = op(q, 2, e);

	  const double gradX = grad[qy][qx][0];
	  const double gradY = grad[qy][qx][1];

	  grad[qy][qx][0] = (O11 * gradX) + (O12 * gradY);
	  grad[qy][qx][1] = (O12 * gradX) + (O22 * gradY);
	}
      }

      for (int qy = 0; qy < Q1D; ++qy) {
	double gradX[D1D][2];
	for (int dx = 0; dx < D1D; ++dx) {
	  gradX[dx][0] = 0;
	  gradX[dx][1] = 0;
	}

	for (int qx = 0; qx < Q1D; ++qx) {
	  const double gX = grad[qy][qx][0];
	  const double gY = grad[qy][qx][1];
	  for (int dx = 0; dx < D1D; ++dx) {
	    const double wx  = Bt(dx, qx);
	    const double wDx = Gt(dx, qx);
	    gradX[dx][0] += gX * wDx;
	    gradX[dx][1] += gY * wx;
	  }
	}

	for (int dy = 0; dy < D1D; ++dy) {
	  const double wy  = Bt(dy, qy);
	  const double wDy = Gt(dy, qy);
	  for (int dx = 0; dx < D1D; ++dx) {
	    Y(dx, dy, e) += ((gradX[dx][0] * wy) +
			     (gradX[dx][1] * wDy));
	  }
	}
      }
    }
  }
}


// TW version (global to global)
// these are guesses for how many elements to process in a thread-block
#if Q1D==1
#define E2D 64
#elif Q1D==2
#define E2D 32
#elif Q1D==3
#define E2D 21
#elif Q1D==4
#define E2D 16
#elif Q1D==5
#define E2D 12
#elif Q1D==6
#define E2D 10
#elif Q1D==7
#define E2D 9
#elif Q1D==8
#define E2D 8
#elif Q1D==9
#define E2D 5
#elif Q1D==10
#define E2D 4
#else
#define E2D 1
#endif


// TW VERSION
@kernel void DiffusionApply2D_GPU(const int NE,
				  @restrict const int *gatherMap,
                                  @restrict const double *B, 
                                  @restrict const double *G,
                                  @restrict const double *Bt,
                                  @restrict const double *Gt,
                                  @restrict const double *op,
                                  @restrict const double *X,
                                  @restrict double *Y) {
  // Iterate over elements
  for (int eOff = 0; eOff < NE; eOff += E2D; @outer) {

    // Store dof <--> quad mappings
    @shared double s_B[Q1D][D1D];
    @shared double s_G[Q1D][D1D];
    
    // Store xy planes in @shared memory
    @shared double s_wk0[E2D][M1D][M1D];
    @shared double s_wk1[E2D][M1D][M1D];

    // Registers for thread local values
    @exclusive double r_u, r_v;

    // Reuse wk0 for input
#define s_X s_wk0

    // element number for this thread
    @exclusive int e, globalId, globalSign;
    
    for(int ez = 0; ez < E2D; ++ez; @inner(2))
      for(int qy = 0; qy < M1D; ++qy; @inner(1))
	for(int qx = 0; qx < M1D; ++qx; @inner(0))
	  {
	    // load B(asis) and G(radient) matrices
	    int dx = qx, dy = qy;
	    if(dx<D1D && ez==0)
	      {
		int id = qy + Q1D*dx;
		s_B[qy][dx] = B[id]; // check this
		s_G[qy][dx] = G[id];
	      }
	    
	    // find element for this thread
	    e = ez + eOff;
	    if(e<NE && dx<D1D && dy<D1D)
	      {
		// TW this needs to be fixed for multiple fields
		// find global index
		const int gid = gatherMap[e*D2D+dy*D1D+dx];
		// check if non-negative
		const bool plus = gid >= 0;
		// adjust look up based on if bc or not
		globalId = plus ? gid : -1-gid;
		// look up value
		double Xgid = X[globalId];
		globalSign = (plus) ? 1:-1;
		// adjust sign based on plus
		s_X[ez][dy][dx] = globalSign*Xgid;
	      }
	  }
    
    
    for(int ez = 0; ez < E2D; ++ez; @inner(2))
      for(int dy = 0; dy < M1D; ++dy; @inner(1))
	for(int qx = 0; qx < M1D; ++qx; @inner(0))
	  {
	    double u = 0.0;
	    double v = 0.0;
	    
	    if(qx<Q1D && dy<D1D){
#pragma unroll D1D
	      for(int dx = 0; dx < D1D; ++dx){
		const double coords = s_X[ez][dy][dx];
		u += s_G[qx][dx] * coords;
		v += s_B[qx][dx] * coords;
	      }
	      r_u = u;
	      r_v = v;
	    }
	  }

    // swap reg<>shared
    for(int ez = 0; ez < E2D; ++ez; @inner(2))
      for(int qy = 0; qy < M1D; ++qy; @inner(1))
	for(int qx = 0; qx < M1D; ++qx; @inner(0))
	  {
	    s_wk0[ez][qy][qx] = r_u;
	    s_wk1[ez][qy][qx] = r_v;
	  }
    
    for(int ez = 0; ez < E2D; ++ez; @inner(2))
      for(int qy = 0; qy < M1D; ++qy; @inner(1))
	for(int qx = 0; qx < M1D; ++qx; @inner(0))
	  {
	    if(qx<Q1D && qy<Q1D){
	      // prefetch Jacobian values
	      double O11 = 0, O12 = 0, O21 = 0, O22 = 0;
	    
	      if(e<NE){
		int Ngeo = 3;
		int id = e*Ngeo*Q2D  + qy*Q1D + qx;
		O11 = op[id+0*Q2D];
		O21 = op[id+1*Q2D];
		O22 = op[id+2*Q2D];
		O12 = O21;
	      }
	    
	      double gX = 0.0;
	      double gY = 0.0;
#pragma unroll D1D
	      for(int dy = 0; dy < D1D; ++dy){
		gX += s_wk0[ez][dy][qx] * s_B[qy][dy];
		gY += s_wk1[ez][dy][qx] * s_G[qy][dy];
	      }
	      r_u = (O11 * gX) + (O12 * gY);
	      r_v = (O21 * gX) + (O22 * gY);
	    }
	  }
    
    // swap reg<>shared
    for(int ez = 0; ez < E2D; ++ez; @inner(2))
      for(int qy = 0; qy < M1D; ++qy; @inner(1))
	for(int qx = 0; qx < M1D; ++qx; @inner(0))
	  {
	    s_wk0[ez][qy][qx] = r_u;
	    s_wk1[ez][qy][qx] = r_v;
	  }

    
    for(int ez = 0; ez < E2D; ++ez; @inner(2))      
      for(int qy = 0; qy < M1D; ++qy; @inner(1))	
	for(int dx = 0; dx < M1D; ++dx; @inner(0))
	  {
	    if(dx<D1D && qy<Q1D){
	      double u = 0.0;
	      double v = 0.0;
	      
#pragma unroll Q1D
	      for (int qx = 0; qx < Q1D; ++qx)
		{
		  u += s_G[qx][dx] * s_wk0[ez][qy][qx]; // TW
		  v += s_B[qx][dx] * s_wk1[ez][qy][qx];
		}
	      
	      r_u = u;
	      r_v = v;
	    }
	  }
    
    // swap reg<>shared
    for(int ez = 0; ez < E2D; ++ez; @inner(2))
      for(int qy = 0; qy < M1D; ++qy; @inner(1))
	for(int qx = 0; qx < M1D; ++qx; @inner(0))
	  {
	    if(qx<Q1D && qy<Q1D){
	      s_wk0[ez][qy][qx] = r_u;
	      s_wk1[ez][qy][qx] = r_v;
	    }
	  }
      
    for(int ez = 0; ez < E2D; ++ez; @inner(2))
      for(int dy = 0; dy < M1D; ++dy; @inner(1))
	for(int dx = 0; dx < M1D; ++dx; @inner(0))
	  {
	    if(dx<D1D && dy<D1D && e<NE){
	      //	      double u = Y[dx+dy*D1D+e*D2D];
	      double u = 0;
	      
#pragma unroll Q1D
	      for (int qy = 0; qy < Q1D; ++qy)
		{
		  u += s_wk0[ez][qy][dx] * s_B[qy][dy];
		  u += s_wk1[ez][qy][dx] * s_G[qy][dy];
		}
	      // retrieve gather sign and index
	      double gsu = globalSign*u;
	      atomicAdd(Y+globalId, gsu);
	    }
	  }
  }
}
#undef s_X

@kernel void DiffusionApply3D_CPU(const int NE,
                                  @restrict const DofToQuad_t B,
                                  @restrict const DofToQuad_t G,
                                  @restrict const QuadToDof_t Bt,
                                  @restrict const QuadToDof_t Gt,
                                  @restrict const SymmOperator3D_t op,
                                  @restrict const DLocal3D_t X,
                                  @restrict DLocal3D_t Y) {
  // Iterate over elements
  for (int e = 0; e < NE; ++e; @outer) {
    for (int dummy = 0; dummy < 1; ++dummy; @inner) {
      double grad[Q1D][Q1D][Q1D][4];
      for (int qz = 0; qz < Q1D; ++qz) {
        for (int qy = 0; qy < Q1D; ++qy) {
          for (int qx = 0; qx < Q1D; ++qx) {
            grad[qz][qy][qx][0] = 0;
            grad[qz][qy][qx][1] = 0;
            grad[qz][qy][qx][2] = 0;
          }
        }
      }

      for (int dz = 0; dz < D1D; ++dz) {
        double gradXY[Q1D][Q1D][4];
        for (int qy = 0; qy < Q1D; ++qy) {
          for (int qx = 0; qx < Q1D; ++qx) {
            gradXY[qy][qx][0] = 0;
            gradXY[qy][qx][1] = 0;
            gradXY[qy][qx][2] = 0;
          }
        }

        for (int dy = 0; dy < D1D; ++dy) {
          double gradX[Q1D][2];
          for (int qx = 0; qx < Q1D; ++qx) {
            gradX[qx][0] = 0;
            gradX[qx][1] = 0;
          }

          for (int dx = 0; dx < D1D; ++dx) {
            const double s = X(dx, dy, dz, e);
            for (int qx = 0; qx < Q1D; ++qx) {
              gradX[qx][0] += s * B(qx, dx);
              gradX[qx][1] += s * G(qx, dx);
            }
          }

          for (int qy = 0; qy < Q1D; ++qy) {
            const double wy  = B(qy, dy);
            const double wDy = G(qy, dy);
            for (int qx = 0; qx < Q1D; ++qx) {
              const double wx  = gradX[qx][0];
              const double wDx = gradX[qx][1];
              gradXY[qy][qx][0] += wDx * wy;
              gradXY[qy][qx][1] += wx  * wDy;
              gradXY[qy][qx][2] += wx  * wy;
            }
          }
        }

        for (int qz = 0; qz < Q1D; ++qz) {
          const double wz  = B(qz, dz);
          const double wDz = G(qz, dz);
          for (int qy = 0; qy < Q1D; ++qy) {
            for (int qx = 0; qx < Q1D; ++qx) {
              grad[qz][qy][qx][0] += gradXY[qy][qx][0] * wz;
              grad[qz][qy][qx][1] += gradXY[qy][qx][1] * wz;
              grad[qz][qy][qx][2] += gradXY[qy][qx][2] * wDz;
            }
          }
        }
      }

      // Calculate Dxyz, xDyz, xyDz in plane
      for (int qz = 0; qz < Q1D; ++qz) {
        for (int qy = 0; qy < Q1D; ++qy) {
          for (int qx = 0; qx < Q1D; ++qx) {
            const int q = QUAD_3D_ID(qx, qy, qz);
            const double O11 = op(q, 0, e);
            const double O12 = op(q, 1, e);
            const double O13 = op(q, 2, e);
            const double O22 = op(q, 3, e);
            const double O23 = op(q, 4, e);
            const double O33 = op(q, 5, e);

            const double gradX = grad[qz][qy][qx][0];
            const double gradY = grad[qz][qy][qx][1];
            const double gradZ = grad[qz][qy][qx][2];

            grad[qz][qy][qx][0] = (O11 * gradX) + (O12 * gradY) + (O13 * gradZ);
            grad[qz][qy][qx][1] = (O12 * gradX) + (O22 * gradY) + (O23 * gradZ);
            grad[qz][qy][qx][2] = (O13 * gradX) + (O23 * gradY) + (O33 * gradZ);
          }
        }
      }

      for (int qz = 0; qz < Q1D; ++qz) {
        double gradXY[D1D][D1D][4];
        for (int dy = 0; dy < D1D; ++dy) {
          for (int dx = 0; dx < D1D; ++dx) {
            gradXY[dy][dx][0] = 0;
            gradXY[dy][dx][1] = 0;
            gradXY[dy][dx][2] = 0;
          }
        }

        for (int qy = 0; qy < Q1D; ++qy) {
          double gradX[D1D][4];
          for (int dx = 0; dx < D1D; ++dx) {
            gradX[dx][0] = 0;
            gradX[dx][1] = 0;
            gradX[dx][2] = 0;
          }

          for (int qx = 0; qx < Q1D; ++qx) {
            const double gX = grad[qz][qy][qx][0];
            const double gY = grad[qz][qy][qx][1];
            const double gZ = grad[qz][qy][qx][2];
            for (int dx = 0; dx < D1D; ++dx) {
              const double wx  = Bt(dx, qx);
              const double wDx = Gt(dx, qx);
              gradX[dx][0] += gX * wDx;
              gradX[dx][1] += gY * wx;
              gradX[dx][2] += gZ * wx;
            }
          }

          for (int dy = 0; dy < D1D; ++dy) {
            const double wy  = Bt(dy, qy);
            const double wDy = Gt(dy, qy);
            for (int dx = 0; dx < D1D; ++dx) {
              gradXY[dy][dx][0] += gradX[dx][0] * wy;
              gradXY[dy][dx][1] += gradX[dx][1] * wDy;
              gradXY[dy][dx][2] += gradX[dx][2] * wy;
            }
          }
        }

        for (int dz = 0; dz < D1D; ++dz) {
          const double wz  = Bt(dz, qz);
          const double wDz = Gt(dz, qz);
          for (int dy = 0; dy < D1D; ++dy) {
            for (int dx = 0; dx < D1D; ++dx) {
              Y(dx, dy, dz, e) += ((gradXY[dy][dx][0] * wz) +
                                   (gradXY[dy][dx][1] * wz) +
                                   (gradXY[dy][dx][2] * wDz));
            }
          }
        }
      }
    }
  }
}

// choose the v0 version for the moment
#define DiffusionApply3D_GPU_v1 DiffusionApply3D_GPU

// Tim Warburton version derived using techniques from:
// Świrydowicz, Kasia, Noel Chalmers, Ali Karakus, and Tim Warburton. 
// "Acceleration of tensor-product operations for high-order finite element methods."
// The International Journal of High Performance Computing Applications 33, no. 4 (2019): 735-757.
//
// This version is designed to use a relatively small amount of shared memory ** and ** register space
@kernel void DiffusionApply3D_GPU_v0(const int NE,
				  @restrict const int *gatherMap,
				  @restrict const double *B, 
                                  @restrict const double *GG,
                                  @restrict const double *Bt,
                                  @restrict const double *Gt,
                                  @restrict const double *op,
                                  @restrict const double *X,
                                  @restrict double *Y) {

  for(int e=0;e<NE;++e;@outer(0)){

    @shared double s_q[Q1D][Q1D][Q1D];
    @shared double s_Jqr[Q1D][Q1D];
    @shared double s_Jqs[Q1D][Q1D];
    
    @shared double s_B[Q1D][D1D];
    @shared double s_GG[Q1D][Q1D];
    
    @exclusive double r_wk[Q1D];

    for(int b=0;b<M1D;++b;@inner(1)){
      for(int a=0;a<M1D;++a;@inner(0)){
	if(a<D1D && b<Q1D){
	  s_B[b][a] = B[b+Q1D*a];
	}
	// check the format for this
	if(a<Q1D && b<Q1D){
	  s_GG[b][a] = GG[b*Q1D+a];
	}
      }
    }

    @barrier("local");
    
    // interp in 't'
    for(int b=0;b<M1D;++b;@inner(1)){
      for(int a=0;a<M1D;++a;@inner(0)){

	for(int k=0;k<Q1D;++k){
	  r_wk[k] = 0;
	}

	if(a<D1D && b<D1D){
	  
	  //#pragma unroll D1D
	  for(int c=0;c<D1D;++c){
	    
	    // TW this needs to be fixed for multiple fields
	    // find global index
	    const int gid = gatherMap[e*D3D+c*D1D*D1D + b*D1D + a];
	    // check if non-negative
	    const bool plus = gid >= 0;
	    // adjust look up based on if bc or not
	    int globalId = plus ? gid : -1-gid;
	    // look up value
	    double Xgid = X[globalId];
	    int globalSign = (plus) ? 1:-1;

	    // load
	    double q_cba  = globalSign*Xgid;

	    //#pragma unroll Q1D
	    for(int k=0;k<Q1D;++k){
	      r_wk[k] += s_B[k][c]*q_cba;
	    }
	  }

	  for(int k=0;k<Q1D;++k){
	    s_q[k][b][a] = r_wk[k];
	  }
	}
	for(int k=0;k<Q1D;++k){
	  r_wk[k] = 0;
	}
      }
    }

    // transform in 's'
    for(int k=0;k<M1D;++k;@inner(1)){
      for(int a=0;a<M1D;++a;@inner(0)){
	if(a<D1D && k<Q1D){

	  //#pragma unroll D1D
	  for(int b=0;b<D1D;++b){
	    double q_kba = s_q[k][b][a];
	    //#pragma unroll Q1D
	    for(int j=0;j<Q1D;++j){
	      r_wk[j] += s_B[j][b]*q_kba;
	    }
	  }
	
	  for(int j=0;j<Q1D;++j){
	    s_q[k][j][a] = r_wk[j];
	  }
	}
	for(int j=0;j<Q1D;++j){
	  r_wk[j] = 0;
	}
      }
    }
    
    // transform in 'r'
    for(int k=0;k<M1D;++k;@inner(1)){
      for(int j=0;j<M1D;++j;@inner(0)){

	if(j<Q1D && k<Q1D){
	  //#pragma unroll D1D
	  for(int a=0;a<D1D;++a){
	    double q_kja = s_q[k][j][a];
	    //#pragma unroll Q1D
	    for(int i=0;i<Q1D;++i){
	      r_wk[i] += s_B[i][a]*q_kja;
	    }
	  }
	  
	  for(int i=0;i<Q1D;++i){
	    s_q[k][j][i] = r_wk[i];
	  }
	}

	for(int i=0;i<Q1D;++i){
	  r_wk[i] = 0;
	}
      }
    }

#pragma unroll Q1D
    for(int k=0;k<Q1D;++k){

      @barrier("local");
      
      for(int j=0;j<M1D;++j;@inner(1)){
	for(int i=0;i<M1D;++i;@inner(0)){

	  if(i<Q1D && j<Q1D){
	    double qr = 0, qs = 0, qt = 0;

	    //#pragma unroll Q1D
	    for(int n=0;n<Q1D;++n){
	      qr += s_GG[i][n]*s_q[k][j][n]; // max 2*12TB/s / 16 => 1.5TF/s
	      qs += s_GG[j][n]*s_q[k][n][i];
	      qt += s_GG[k][n]*s_q[n][j][i];
	    }

	    // hard coded parameters
	    const int gbase = e*6*Q3D + i + j*Q1D + k*Q1D*Q1D;
	    const double G00 = op[gbase+0*Q3D];
	    const double G01 = op[gbase+1*Q3D];
	    const double G02 = op[gbase+2*Q3D];
	    const double G11 = op[gbase+3*Q3D];
	    const double G12 = op[gbase+4*Q3D];
	    const double G22 = op[gbase+5*Q3D];
	  
	    double Jqr = G00*qr + G01*qs + G02*qt;
	    double Jqs = G01*qr + G11*qs + G12*qt;
	    double Jqt = G02*qr + G12*qs + G22*qt;
	  
	    s_Jqr[j][i] = Jqr;
	    s_Jqs[j][i] = Jqs;

	    //#pragma unroll Q1D
	    for(int n=0;n<Q1D;++n){
	      r_wk[n] += s_GG[k][n]*Jqt;
	    }
	  }
	}
      }
      
      @barrier("local");
      
      for(int j=0;j<M1D;++j;@inner(1)){
	for(int i=0;i<M1D;++i;@inner(0)){
	  if(i<Q1D && j<Q1D){
	    //#pragma unroll Q1D
	    for(int n=0;n<Q1D;++n){
	      r_wk[k] += s_GG[n][i]*s_Jqr[j][n];
	      r_wk[k] += s_GG[n][j]*s_Jqs[n][i];
	    }
	  }
	}
      }
    }

    for(int j=0;j<M1D;++j;@inner(1)){
      for(int i=0;i<M1D;++i;@inner(0)){
	if(i<Q1D && j<Q1D){
	  for(int k=0;k<Q1D;++k){
	    s_q[k][j][i] = r_wk[k];
	  }
	}
      }
    }

    // test in 'r'
    for(int k=0;k<M1D;++k;@inner(1)){
      for(int j=0;j<M1D;++j;@inner(0)){
	if(j<Q1D && k<Q1D){
	  for(int i=0;i<Q1D;++i){
	    r_wk[i] = s_q[k][j][i];
	  }
	
	  //#pragma unroll D1D
	  for(int a=0;a<D1D;++a){
	    double tmp = 0;
	    //#pragma unroll Q1D
	    for(int i=0;i<Q1D;++i){
	      tmp += s_B[i][a]*r_wk[i]; // 3TF/s
	    }
	    s_q[k][j][a] = tmp;
	  }
	}
      }
    }

    // test in 's'
    for(int k=0;k<M1D;++k;@inner(1)){
      for(int a=0;a<M1D;++a;@inner(0)){
	if(a<D1D && k<Q1D){
	  for(int j=0;j<Q1D;++j){
	    r_wk[j] = s_q[k][j][a];
	  }
	  
	  //#pragma unroll D1D
	  for(int b=0;b<D1D;++b){
	    double tmp = 0;
	    //#pragma unroll Q1D
	    for(int j=0;j<Q1D;++j){
	      tmp += s_B[j][b]*r_wk[j]; // 3TF/s
	    }
	    s_q[k][b][a] = tmp;
	  }
	}
      }
    }


    // test in 't' and store
    for(int b=0;b<M1D;++b;@inner(1)){
      for(int a=0;a<M1D;++a;@inner(0)){
	if(a<D1D && b<D1D){
	  for(int k=0;k<Q1D;++k){
	    r_wk[k] = s_q[k][b][a];
	  }
	  //#pragma unroll D1D
	  for(int c=0;c<D1D;++c){
	    double tmp = 0;
	    //#pragma unroll Q1D
	    for(int k=0;k<Q1D;++k){
	      tmp += s_B[k][c]*r_wk[k]; // 3TF/s
	    }
	    
	    const int gid = gatherMap[e*D3D+c*D1D*D1D + b*D1D + a];
	    // check if non-negative
	    const bool plus = gid >= 0;
	    // adjust look up based on if bc or not
	    int globalId = plus ? gid : -1-gid;
	    // look up value
	    int globalSign = (plus) ? 1:-1;
	    
	    // load
	    double Aq_cba  = globalSign*tmp;
	    atomicAdd(Y+globalId, Aq_cba);
	  }
	}
      }
    }
  }
}


// Kernel 9 - all partial results are stored in the shared memory
#if M1D<=10
@kernel void DiffusionApply3D_GPU_v1(const int NE,
				     @restrict const int *gatherMap,
				     @restrict const double *B, 
				     @restrict const double *GG,
				     @restrict const double *Bt,
				     @restrict const double *Gt,
				     @restrict const double *op,
				     @restrict const double *X,
				     @restrict double *Y) {

  for(int e=0; e<NE; ++e; @outer(0)) {

    @shared double s_X[Q1D][Q1D][Q1D];
    @shared double s_X1[Q1D][Q1D][Q1D];
    @shared double s_X2[Q1D][Q1D][Q1D];
    @shared double s_X3[Q1D][Q1D][Q1D];

    @shared double s_GG[Q1D][Q1D];
    @shared double s_B[Q1D][D1D];

    @exclusive int globalSign, globalId;
    
    for(int c=0; c<M1D; ++c; @inner(2)) {
      for(int b=0; b<M1D; ++b; @inner(1)) {
        for(int a=0; a<M1D; ++a; @inner(0)) {
	  
          if (c == 0 && a<D1D && b<Q1D) {
            s_B[b][a] = B[b+Q1D*a];
          }

          if (a<Q1D && b<Q1D && c==0 ) {
            s_GG[b][a] = GG[b*Q1D+a];
          }

	  if(c<D1D && b<D1D && a<D1D){
	    // TW this needs to be fixed for multiple fields
	    // find global index
	    const int gid = gatherMap[e*D3D+c*D1D*D1D + b*D1D + a];
	    // check if non-negative
	    const bool plus = gid >= 0;
	    // adjust look up based on if bc or not
	    globalId = plus ? gid : -1-gid;
	    // look up value
	    double Xgid = X[globalId];
	    globalSign = (plus) ? 1:-1;
	    
	    // load
            s_X2[c][b][a] = globalSign*Xgid;
	  }
        }//for a
      }// for b
    }//for c

  
    //============== interpolate in 3 dir ========================
    // r --> s --> t

    for(int c=0; c<M1D; ++c; @inner(2)) {
      for(int b=0; b<M1D; ++b; @inner(1)) {
        for(int i=0; i<M1D; ++i; @inner(0)) {

          if (c<D1D && b<D1D && i<Q1D){

	    double res = 0;
	    
#pragma unroll D1D
	    for(int n=0; n<D1D; ++n) {
	      res += s_B[i][n]*s_X2[c][b][n];
	    }
	    
	    s_X[c][b][i] = res;
          }
        }
      }
    }

    for(int c=0; c<M1D; ++c; @inner(2)) {
      for(int j=0; j<M1D; ++j; @inner(1)) {
        for(int i=0; i<M1D; ++i; @inner(0)) {

          if(c<D1D && j<Q1D && i<Q1D) {

	    double res = 0;
	    
#pragma unroll D1D
	    for(int n=0; n<D1D; ++n) {
	      res += s_B[j][n]*s_X[c][n][i];
	    }
	    s_X2[c][j][i] = res;
          }
        }
      }
    }

    // t direction
    for(int k=0; k<M1D; ++k; @inner(2)) {
      for(int j=0; j<M1D; ++j; @inner(1)) {
        for(int i=0; i<M1D; ++i; @inner(0)) {

          if(k<Q1D && j<Q1D && i<Q1D) {
	    
	    double res = 0;
	    
#pragma unroll D1D
            for(int n=0; n<D1D; ++n) {
              res += s_B[k][n]*s_X2[n][j][i];
            }

	    s_X[k][j][i] = res;
	  }
        }
      }
    }
    
  
    for(int k=0; k<M1D; ++k; @inner(2)) {
      for(int j=0; j<M1D; ++j; @inner(1)) {
        for(int i=0; i<M1D; ++i; @inner(0)) {

          if(k<Q1D && j<Q1D && i<Q1D) {
	    
	    const int gbase = e*6*Q3D + i + j*Q1D + k*Q1D*Q1D;
	    const double G00 = op[gbase+0*Q3D];
	    const double G01 = op[gbase+1*Q3D];
	    const double G02 = op[gbase+2*Q3D];
	    const double G11 = op[gbase+3*Q3D];
	    const double G12 = op[gbase+4*Q3D];
	    const double G22 = op[gbase+5*Q3D];
	    
	    double dr = 0.0f;
	    double ds = 0.0f;
	    double dt = 0.0f;
	    
#pragma unroll Q1D
            for (int n = 0; n<Q1D; ++n) {
              dr += s_GG[i][n] * s_X[k][j][n];
              ds += s_GG[j][n] * s_X[k][n][i];
              dt += s_GG[k][n] * s_X[n][j][i];
            }
	    
	    double qr = G00*dr + G01*ds + G02*dt;
	    double qs = G01*dr + G11*ds + G12*dt;
	    double qt = G02*dr + G12*ds + G22*dt;
	    
	    s_X1[k][j][i] = qr;
	    s_X2[k][j][i] = qs;
	    s_X3[k][j][i] = qt;
	  }
	}
      }
    }
    
    for(int k=0; k<M1D; ++k; @inner(2)) {
      for(int j=0; j<M1D; ++j; @inner(1)) {
        for(int i=0; i<M1D; ++i; @inner(0)) {


          if(k<Q1D && j<Q1D && i<Q1D) {
	    
	    double tmp = 0.f;
	    
#pragma unroll Q1D
	    for(int m=0; m<Q1D; ++m) {
	      tmp += s_GG[m][i]*s_X1[k][j][m];
              tmp += s_GG[m][j]*s_X2[k][m][i];
              tmp += s_GG[m][k]*s_X3[m][j][i];
            }
	    
	    s_X[k][j][i] =  tmp;
	  }
	}
      }
    }
  
    // t first
    for(int c=0; c<M1D; ++c; @inner(2)) {
      for(int j=0; j<M1D; ++j; @inner(1)) {
        for(int i=0; i<M1D; ++i; @inner(0)) {
	  
          double Iq = 0.0f;

	  
          if(c<D1D && j<Q1D && i<Q1D) {
	    
#pragma unroll Q1D
              for(int m=0; m<Q1D; ++m) {
                Iq += s_B[m][c]*s_X[m][j][i];
              }
          }
	  
          s_X2[c][j][i] = Iq;
        }
      }
    }


    // r direction
    for(int c=0; c<M1D; ++c; @inner(2)) {
      for(int b=0; b<M1D; ++b; @inner(1)) {
        for(int i=0; i<M1D; ++i; @inner(0)) {

          if(c<D1D && b<D1D && i<Q1D){

            double Iq = 0.0f;

#pragma unroll Q1D
              for(int m=0; m<Q1D; ++m) {
                Iq += s_B[m][b]*s_X2[c][m][i];
              }

            s_X[c][b][i] = Iq;
          }
        }
      }
    }
  
    for(int c=0; c<M1D; ++c; @inner(2)) {
      for(int b=0; b<M1D; ++b; @inner(1)) {
        for(int a=0; a<M1D; ++a; @inner(0)) {
	  
          if (c<D1D && b<D1D && a< D1D){
	    
            double Iq = 0.0f;
	    
#pragma unroll Q1D
	    for(int m=0; m<Q1D; ++m) {
	      Iq += s_B[m][a]*s_X[c][b][m];
	    }

	    Iq *= globalSign;
	    
	    atomicAdd(Y+globalId, Iq);
          }
        }
      }
    }
  }
} 
#endif



@kernel void MassApply2D_CPU(const int NE,
                             @restrict const DofToQuad_t B,
                             @restrict const QuadToDof_t Bt,
                             @restrict const QLocal2D_t op,
                             @restrict const DLocal2D_t X,
                             @restrict DLocal2D_t Y) {
  for (int e = 0; e < NE; ++e; @outer) {
    for (int dummy = 0; dummy < 1; ++dummy; @inner) {
      double sol_xy[Q1D][Q1D];

      for (int qy = 0; qy < Q1D; ++qy) {
        for (int qx = 0; qx < Q1D; ++qx) {
          sol_xy[qy][qx] = 0;
        }
      }

      for (int dy = 0; dy < D1D; ++dy) {
        double sol_x[Q1D];
        for (int qy = 0; qy < Q1D; ++qy) {
          sol_x[qy] = 0;
        }

        for (int dx = 0; dx < D1D; ++dx) {
          const double s = X(dx, dy, e);
          for (int qx = 0; qx < Q1D; ++qx) {
            sol_x[qx] += B(qx, dx) * s;
          }
        }

        for (int qy = 0; qy < Q1D; ++qy) {
          const double d2q = B(qy, dy);
          for (int qx = 0; qx < Q1D; ++qx) {
            sol_xy[qy][qx] += d2q * sol_x[qx];
          }
        }
      }

      for (int qy = 0; qy < Q1D; ++qy) {
        for (int qx = 0; qx < Q1D; ++qx) {
          sol_xy[qy][qx] *= op(qx, qy, e);
        }
      }

      for (int qy = 0; qy < Q1D; ++qy) {
        double sol_x[D1D];
        for (int dx = 0; dx < D1D; ++dx) {
          sol_x[dx] = 0;
        }

        for (int qx = 0; qx < Q1D; ++qx) {
          const double s = sol_xy[qy][qx];
          for (int dx = 0; dx < D1D; ++dx) {
            sol_x[dx] += Bt(dx, qx) * s;
          }
        }

        for (int dy = 0; dy < D1D; ++dy) {
          const double q2d = Bt(dy, qy);
          for (int dx = 0; dx < D1D; ++dx) {
            Y(dx, dy, e) += q2d * sol_x[dx];
          }
        }
      }
    }
  }
}

@kernel void MassApply3D_CPU(const int NE,
                             @restrict const DofToQuad_t B,
                             @restrict const QuadToDof_t Bt,
                             @restrict const QLocal3D_t op,
                             @restrict const DLocal3D_t X,
                             @restrict DLocal3D_t Y) {
  // Iterate over elements
  for (int e = 0; e < NE; ++e; @outer) {
    for (int dummy = 0; dummy < 1; ++dummy; @inner) {
      double sol_xyz[Q1D][Q1D][Q1D];
      for (int qz = 0; qz < Q1D; ++qz) {
        for (int qy = 0; qy < Q1D; ++qy) {
          for (int qx = 0; qx < Q1D; ++qx) {
            sol_xyz[qz][qy][qx] = 0;
          }
        }
      }

      for (int dz = 0; dz < D1D; ++dz) {
        double sol_xy[Q1D][Q1D];
        for (int qy = 0; qy < Q1D; ++qy) {
          for (int qx = 0; qx < Q1D; ++qx) {
            sol_xy[qy][qx] = 0;
          }
        }

        for (int dy = 0; dy < D1D; ++dy) {
          double sol_x[Q1D];
          for (int qx = 0; qx < Q1D; ++qx) {
            sol_x[qx] = 0;
          }

          for (int dx = 0; dx < D1D; ++dx) {
            const double s = X(dx, dy, dz, e);
            for (int qx = 0; qx < Q1D; ++qx) {
              sol_x[qx] += B(qx, dx) * s;
            }
          }

          for (int qy = 0; qy < Q1D; ++qy) {
            const double wy = B(qy, dy);
            for (int qx = 0; qx < Q1D; ++qx) {
              sol_xy[qy][qx] += wy * sol_x[qx];
            }
          }
        }

        for (int qz = 0; qz < Q1D; ++qz) {
          const double wz = B(qz, dz);
          for (int qy = 0; qy < Q1D; ++qy) {
            for (int qx = 0; qx < Q1D; ++qx) {
              sol_xyz[qz][qy][qx] += wz * sol_xy[qy][qx];
            }
          }
        }
      }

      for (int qz = 0; qz < Q1D; ++qz) {
        for (int qy = 0; qy < Q1D; ++qy) {
          for (int qx = 0; qx < Q1D; ++qx) {
            sol_xyz[qz][qy][qx] *= op(qx, qy, qz, e);
          }
        }
      }

      for (int qz = 0; qz < Q1D; ++qz) {
        double sol_xy[D1D][D1D];
        for (int dy = 0; dy < D1D; ++dy) {
          for (int dx = 0; dx < D1D; ++dx) {
            sol_xy[dy][dx] = 0;
          }
        }

        for (int qy = 0; qy < Q1D; ++qy) {
          double sol_x[D1D];
          for (int dx = 0; dx < D1D; ++dx) {
            sol_x[dx] = 0;
          }

          for (int qx = 0; qx < Q1D; ++qx) {
            const double s = sol_xyz[qz][qy][qx];
            for (int dx = 0; dx < D1D; ++dx) {
              sol_x[dx] += Bt(dx, qx) * s;
            }
          }

          for (int dy = 0; dy < D1D; ++dy) {
            const double wy = Bt(dy, qy);
            for (int dx = 0; dx < D1D; ++dx) {
              sol_xy[dy][dx] += wy * sol_x[dx];
            }
          }
        }

        for (int dz = 0; dz < D1D; ++dz) {
          const double wz = Bt(dz, qz);
          for (int dy = 0; dy < D1D; ++dy) {
            for (int dx = 0; dx < D1D; ++dx) {
              Y(dx, dy, dz, e) += wz * sol_xy[dy][dx];
            }
          }
        }
      }
    }
  }
}


// TW VERSION
@kernel void MassApply2D_GPU(const int NE,
                                  @restrict const double *B, 
                                  @restrict const double *Bt,
                                  @restrict const double *op,
                                  @restrict const double *X,
                                  @restrict double *Y) {
  // Iterate over elements
  for (int eOff = 0; eOff < NE; eOff += E2D; @outer) {

    // Store dof <--> quad mappings
    @shared double s_B[Q1D][D1D];
    
    // Store xy planes in @shared memory
    @shared double s_wk0[E2D][M1D][M1D];
    @shared double s_wk1[E2D][M1D][M1D];

    // element number for this thread
    @exclusive int e;
    
    for(int ez = 0; ez < E2D; ++ez; @inner(2))
      for(int qy = 0; qy < M1D; ++qy; @inner(1))
	for(int qx = 0; qx < M1D; ++qx; @inner(0))
	  {
	    // load B(asis) and G(radient) matrices
	    int dx = qx, dy = qy;
	    if(dx<D1D && ez==0)
	      {
		int id = qy + Q1D*dx;
		s_B[qy][dx] = B[id]; // check this
	      }
	    
	    // find element for this thread
	    e = ez + eOff;

	    if(e<NE){
	      s_wk0[ez][dy][dx] = X[e*D2D+dy*D1D+dx];
	    }
	  }
    
    
    for(int ez = 0; ez < E2D; ++ez; @inner(2))
      for(int dy = 0; dy < M1D; ++dy; @inner(1))
	for(int qx = 0; qx < M1D; ++qx; @inner(0))
	  {
	    double u = 0.0;
	    
	    if(qx<Q1D && dy<D1D){
#pragma unroll D1D
	      for(int dx = 0; dx < D1D; ++dx){
		const double coords = s_wk0[ez][dy][dx];
		u += s_B[qx][dx] * coords;
	      }
	      s_wk1[ez][dy][qx] = u;
	    }
	  }

    for(int ez = 0; ez < E2D; ++ez; @inner(2))
      for(int qy = 0; qy < M1D; ++qy; @inner(1))
	for(int qx = 0; qx < M1D; ++qx; @inner(0))
	  {
	    if(qx<Q1D && qy<Q1D){
	      // prefetch Jacobian values
	      double JW = 0;
	    
	      if(e<NE){
		int id = e*Q2D  + qy*Q1D + qx;
		JW = op[id];
	      }
	    
	      double gX = 0.0;
#pragma unroll D1D
	      for(int dy = 0; dy < D1D; ++dy){
		gX += s_wk1[ez][dy][qx] * s_B[qy][dy];
	      }
	      s_wk0[ez][qy][qx] = JW*gX;
	    }
	  }
  

    
    for(int ez = 0; ez < E2D; ++ez; @inner(2))      
      for(int qy = 0; qy < M1D; ++qy; @inner(1))	
	for(int dx = 0; dx < M1D; ++dx; @inner(0))
	  {
	    if(dx<D1D && qy<Q1D){
	      double u = 0.0;
	      
#pragma unroll Q1D
	      for (int qx = 0; qx < Q1D; ++qx)
		{
		  u += s_B[qx][dx] * s_wk0[ez][qy][qx]; // TW
		}
	      
	      s_wk1[ez][qy][dx] = u;
	    }
	  }
    
    for(int ez = 0; ez < E2D; ++ez; @inner(2))
      for(int dy = 0; dy < M1D; ++dy; @inner(1))
	for(int dx = 0; dx < M1D; ++dx; @inner(0))
	  {
	    if(dx<D1D && dy<D1D && e<NE){
	      double u = 0;
	      
#pragma unroll Q1D
	      for (int qy = 0; qy < Q1D; ++qy)
		{
		  u += s_wk1[ez][qy][dx] * s_B[qy][dy];
		}
	      // retrieve gather sign and index
	      if(e<NE){
		int id = e*D2D + dy*D1D + dx;
		Y[id] += u;
	      }
	    }
	  }
  }
}




// Tim Warburton version derived using techniques from:
// Świrydowicz, Kasia, Noel Chalmers, Ali Karakus, and Tim Warburton. 
// "Acceleration of tensor-product operations for high-order finite element methods."
// The International Journal of High Performance Computing Applications 33, no. 4 (2019): 735-757.
//
// This version is designed to use a relatively small amount of shared memory ** and ** register space
@kernel void MassApply3D_GPU(const int NE,
				  @restrict const double *B, 
                                  @restrict const double *Bt,
                                  @restrict const double *op,
                                  @restrict const double *X,
                                  @restrict double *Y) {

  for(int e=0;e<NE;++e;@outer(0)){

    @shared double s_q[Q1D][Q1D][Q1D];
    @shared double s_B[Q1D][D1D];
    
    @exclusive double r_wk[Q1D];

    for(int b=0;b<M1D;++b;@inner(1)){
      for(int a=0;a<M1D;++a;@inner(0)){

	// load B basis matrix 
	if(a<D1D && b<Q1D){
	  s_B[b][a] = B[b+Q1D*a];
	}

	// clear register array
	for(int i=0;i<Q1D;++i){
	  r_wk[i] = 0;
	}

	// load X data
	if(a<D1D && b<D1D){
	  
	  //#pragma unroll D1D
	  for(int c=0;c<D1D;++c){
	    // load
	    s_q[c][b][a] = X[e*D3D+c*D1D*D1D + b*D1D + a];
	  }
	}
      }
    }

    // transform in 'r'
    for(int c=0;c<M1D;++c;@inner(1)){
      for(int b=0;b<M1D;++b;@inner(0)){
	if(b<D1D && c<D1D){

	  //	  #pragma unroll D1D
	  for(int a=0;a<D1D;++a){
	    double q_kba = s_q[c][b][a];
	    //	    #pragma unroll Q1D
	    for(int i=0;i<Q1D;++i){
	      r_wk[i] += s_B[i][a]*q_kba; // 3 TF/s
	    }
	  }
	
	  for(int i=0;i<Q1D;++i){
	    s_q[c][b][i] = r_wk[i];
	  }
	}
	for(int j=0;j<Q1D;++j){
	  r_wk[j] = 0;
	}
      }
    }

    // transform in 's'
    for(int c=0;c<M1D;++c;@inner(1)){
      for(int i=0;i<M1D;++i;@inner(0)){
	if(i<Q1D && c<D1D){

	  //#pragma unroll D1D
	  for(int b=0;b<D1D;++b){
	    double q_cbi = s_q[c][b][i];
	    //#pragma unroll Q1D
	    for(int j=0;j<Q1D;++j){
	      r_wk[j] += s_B[j][b]*q_cbi; // 3 TF/s
	    }
	  }
	
	  for(int j=0;j<Q1D;++j){
	    s_q[c][j][i] = r_wk[j];
	  }
	}
	for(int k=0;k<Q1D;++k){
	  r_wk[k] = 0;
	}
      }
    }
    
    // transform, weight, and test in 't'
    for(int j=0;j<M1D;++j;@inner(1)){
      for(int i=0;i<M1D;++i;@inner(0)){

	if(i<Q1D && j<Q1D){
	  //#pragma unroll D1D
	  for(int c=0;c<D1D;++c){
	    double q_cji = s_q[c][j][i];
	    //#pragma unroll Q1D
	    for(int k=0;k<Q1D;++k){
	      r_wk[k] += s_B[k][c]*q_cji; // 3 TF/s
	    }
	  }

	  //#pragma unroll Q1D
	  for(int k=0;k<Q1D;++k){
	    // hard coded parameters
	    const int gbase = e*Q3D + i + j*Q1D + k*Q1D*Q1D;  // this is not great for coalescing
	    const double JW = op[gbase];
	    
	    r_wk[k] *= JW;
	  }
	
	  for(int c=0;c<D1D;++c){
	    double tmp = 0;
	    //#pragma unroll Q1D
	    for(int k=0;k<Q1D;++k){
	      tmp += s_B[k][c]*r_wk[k]; // 3TF/s
	    }
	    s_q[c][j][i] = tmp;
	  }
	}
      }
    }

    // test in 's'
    for(int c=0;c<M1D;++c;@inner(1)){
      for(int i=0;i<M1D;++i;@inner(0)){
	if(i<Q1D && c<D1D){
	  for(int j=0;j<Q1D;++j){
	    r_wk[j] = s_q[c][j][i];
	  }
	  
	  //#pragma unroll D1D
	  for(int b=0;b<D1D;++b){
	    double tmp = 0;
	    //#pragma unroll Q1D
	    for(int j=0;j<Q1D;++j){
	      tmp += s_B[j][b]*r_wk[j]; // 3TF/s
	    }
	    s_q[c][b][i] = tmp;
	  }
	}
      }
    }

    // test in 'r'
    for(int c=0;c<M1D;++c;@inner(1)){
      for(int b=0;b<M1D;++b;@inner(0)){
	if(b<D1D && c<D1D){
	  for(int i=0;i<Q1D;++i){
	    r_wk[i] = s_q[c][b][i];
	  }
	  
	  //#pragma unroll D1D
	  for(int a=0;a<D1D;++a){
	    double tmp = 0;
	    //#pragma unroll Q1D
	    for(int i=0;i<Q1D;++i){
	      tmp += s_B[i][a]*r_wk[i]; // 3TF/s
	    }
	    s_q[c][b][a] = tmp;
	  }
	}
      }
    }

    // store
    for(int b=0;b<M1D;++b;@inner(1)){
      for(int a=0;a<M1D;++a;@inner(0)){
	if(a<D1D && b<D1D){
	  //#pragma unroll D1D
	  for(int c=0;c<D1D;++c){
	    int id = e*D3D + c*D2D + b*D1D + a;
	    Y[id] += s_q[c][b][a];
	  }
	}
      }
    }
  }
}

