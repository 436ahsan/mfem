run:
exMHD -r 2 -o 2 -tf 3 -vs 100 -dt .002
exMHD -r 2 -tf 10 -vs 50 -dt .004 -i 2

Parallel AMR run:
mpirun -n 16 exAMRMHDp -m xperiodicR1.mesh -rs 0 -rp 2 -o 4 -tf 8 -vs 200 -dt .0001 -i 3 -amrl 3 -ltol 2e-3 -derefine

parallel run:
mpirun -n 4 exMHDp -rs 4 -o 2 -tf 3 -vs 100 -dt .001
mpirun -n 4 exMHDp -rs 4 -tf 10 -vs 200 -dt .001 -i 2
mpirun -n 4 exMHDp -m xperiodicR3.mesh -rs 0 -o 4 -tf 8 -vs 100 -dt .001 -i 3

serial AMR quick test:
./exAMRMHD -m xperiodicR3.mesh -r 0 -o 4 -tf .025 -vs 10 -dt .0001 -i 3 -amrl 3 -ltol 1e-3

Parallel AMR quick test:
./exAMRMHDp -m xperiodicR3.mesh -rs 0 -o 4 -tf .025 -vs 10 -dt .0001 -i 3 -amrl 3 -ltol 1e-3

plot:
glvis -m refined.mesh -g current.sol -k "mmcRjl" -ww 800 -wh 800
glvis -m refined.mesh -g psiPer.sol -k "mmc" -ww 800 -wh 800
glvis -m refined.mesh -g phi.sol -k "mmc" -ww 800 -wh 800
glvis -m refined.mesh -g omega.sol -k "mmc" -ww 800 -wh 800


glvis -m refined.mesh -g psiPer.sol -k "mmRjl" -ww 1000 -wh 1000

parallel plot:
glvis -np 1 -m mesh -g sol_omega -k "mmc" -ww 800 -wh 800

5/20
swich J back to auxilary variable (keep the original implement in exMHD for debugging purpose)


5/17
Issues:
x it has to assemble nv and nb each time step, not sure how to do it implicitly (am I doing matrix-free for those two? Probably not)

implemented a new approach based on LinearForm, but it is slower

todo for imMHDp
1. treat J as a true auxiliary variable
2. implement a new class for implicit scheme and reduced operator


5/15
Q1. what happens to GetGradient when factory is used? It is called through __mfem_snes_jacobian
2. Where is Mult implemented now? It is implemented through J->Mult from GetGradient
3. reducedOperator->Mult is something else (not the same)

see submatrix in (a good example on multiphysics coupling)
https://www.mcs.anl.gov/petsc/petsc-current/src/snes/examples/tutorials/ex28.c.html

Question: how could I access the block vec from y??
MatGetLocalSubMatrix
VecGetLocalVector
Those will determine the local matrix and local vectors

Define the linearform operator:
the linear integral order is probably 3k/2
define a special coefficient by myself
then define a linearform and assemble


5/11
-snes_mf_operator is working 


5/6
mpirun -n 1 exAMRMHDp -m xperiodic.mesh -rs 3 -o 4 -tf 8 -vs 10 -dt .0001 -i 3 -amrl 3 -ltol 1e-3
mpirun -n 4 exAMRMHDp -m xperiodic.mesh -rs 3 -o 4 -tf 8 -vs 10 -dt .0001 -i 3 -amrl 3 -ltol 1e-3

derefine in parallel amr working:
mpirun -n 16 exAMRMHDp -m xperiodicR1.mesh -rs 0 -rp 2 -o 4 -tf 8 -vs 200 -dt .0001 -i 3 -amrl 3 -ltol 2e-3 -derefine

5/4
on nersc debug mode has issue (fixed)
make config MFEM_USE_MPI=YES MFEM_DEBUG=YES MPICXX=CC
standard is ok:
make config MFEM_USE_MPI=YES MFEM_DEBUG=NO MPICXX=CC

serial config:
make config MFEM_USE_MPI=NO MFEM_DEBUG=NO CXX=CC

5/3
1. Try derefine
2. Prallel AMR

Consider:
JFNK
Poisson Bracket
SMG
Mixed FEM


4/30
Test it on nersc
srun -n 32 ../exMHDp -m ../xperiodic.mesh -rs 6 -rp 0 -o 3 -tf 1 -vs 2500 -dt .0002 -i 3 -no-vis -visit

profiling this case:
mpirun -n 48 ../exMHDp -m ../xperiodic.mesh -rs 6 -rp 1 -o 3 -tf .1 -vs 1000 -dt .00005 -i 3

4/29
After fixing a bug, parallel code works well:
mpirun -n 96 ../exMHDp -m ../xperiodic.mesh -rs 6 -rp 0 -o 3 -tf 8 -vs 2500 -dt .0002 -i 3 -no-vis -visit

4/27
parallel code appears working

for icase=3
need to reduce rel_tol to invert the mass matrix
it is better to use different rel_tol for mass and stiffness matrices

BoomerAMG is also working
mpirun -n 8 exMHDp -m xperiodic.mesh -rs 3 -rp 2 -o 3 -tf 1 -vs 50 -dt .001 -i 3

4/26
the paralle code sometimes work but sometimes give me unstable results

ok:
mpirun -n 2 exMHDp -rs 2 -tf 10 -vs 50 -dt .004 -i 2
mpirun -n 4 exMHDp -rs 3 -o 3 -tf 3 -vs 100 -dt .001 -no-vis

there is probably a bug in the saving function (got some numbers of 1e-312)

I cannot make vis working. Maybe there is a bug in the code?

this works:
mpirun -n 4 exMHDp -rs 2 -rp 2 -tf 10 -vs 50 -dt .0005 -i 2 -visit -no-vis

this fails on mac (there is a bug somewhere) but works on hpcc:
mpirun -n 4 exMHDp -rs 4 -rp 0 -tf .001 -vs 100 -dt .001 -i 2 -no-vis

this also fails:
mpirun -n 4 exMHDp -rs 2 -o 2 -tf .002 -vs 100 -dt .002

this sometimes works and sometimes not (works on intel14 but not intel16):
mpirun -n 4 exMHDp -rs 2 -o 2 -tf 1.5 -vs 100 -dt .002

4/25
there is a strange bug associate with M->Mult (not consistent in serial and parallel)

4/23
try to benchmark against Pixie2d; the ic example give different resutls with the same initial condition
o found the missing source term in the ic case


4/12
parallel version:
mesh -> ParMesh
FiniteElementSpace -> ParFiniteElementSpace
GridFunction -> ParGridFunction
save solution needs to be changed and visual as well

myCoefficient.hpp? probably could stay sound
Change some preconditioner in ResistiveMHDOperator.hpp


4/10
try:
Start with an AMR mesh
Refine every 1000 time steps
./exAMRMHD -m xperiodicR3.mesh -r 0 -o 4 -tf 8 -vs 10 -dt .0001 -i 3 -amrl 3 -ltol 1e-3

in the inner loop of refinement, I could potential do an iteration!

4/9
grid space 5e-3 at x point for island
try back solve Psi through J! not working!
Evolve current? maybe not there yet

do some iterations first and obtain a better initial grid!!

>>>Do AMR grid generation first
./generateAMR -m xperiodicR3.mesh -r 0 -o 4 -i 3 -amrl 3 -ltol 1e-10

4/8
>>>derefiner is a major source to introduce osscillations
Demo: 129->130 (see the oscillations in omega!):
Number of unknowns: 52336
Number of elements in mesh: 3024
step 130, t = 0.013
Derefined mesh...
True V size = 46496
Problem size = 51952
Number of unknowns: 51952
Number of elements in mesh: 3000

>>>K operator plus an interpolation (and grad J) is the secondary issue

try
./exAMRMHD -m xperiodicR3.mesh -r 0 -o 4 -tf 8 -vs 1000 -dt .0001 -i 3 -amrl 3 -ltol 5e-3 -visit

4/6
this is sort of working
 ./exAMRMHD -m xperiodic.mesh -r 3 -o 4 -tf 10 -vs 50 -dt .0001 -i 3 -ltol 1e-3

after adding refinement level, this works better
./exAMRMHD -m xperiodic.mesh -r 3 -o 4 -tf .02 -vs 50 -dt .0001 -i 3 -amrl 3 -ltol 1e-3


4/5
AMR starts to work after I switch vector size total dofs

4/3
there are some issues for AMR:
o KB add more degrees freedom for nonconforming AMR (see by trun off refiner.SetTotalErrorFraction(0.0))
  I can probably fix it with Mark's suggestion.
x When it did uniform refinement, KB is okay but Current is very osscillatory (P4 is better but I am surprised by the results)
  see (by turn on refiner.SetTotalErrorFraction(0.0)):
  ./exAMRMHD -m xperiodic.mesh -r 3 -o 3 -tf 10 -vs 50 -dt .002 -i 3 -ltol 1e-6
x I do not know how to add the AMR levels (probably control through nc_limit)
x Derefine is not tested yet

there are one issue for nonlinear:
x I have to assemble matrix whenever the nonlinear operator called

o it is not doing uniform refinement any more

We may need to have two requests:
o fix KB for nonconforming AMR
o install the nonlinear operator

4/2
this looks okay, although it does some uniform refinement:
./exAMRMHD -r 3 -o 3 -tf 10 -vs 50 -dt .002 -i 2 -ltol 1e-6

island test:
./exAMRMHD -m xperiodic.mesh -r 3 -o 3 -tf 10 -vs 50 -dt .002 -i 3 -ltol 1e-6

amr test is strange:
current is oscillatory
amr can only do uniform refinement

4/1
there is a strange bug: I have to store coefficients for diffusion operator (deleting them to quick leads to issue in assembling later)
not able to get block vector working with update

3/30
working on amr: 
o define a new estimator: error=erro1+ratio*error2
  Note that since the errors are computed to the total error, it is fine as long as ratio>0.
  By default, ratio = 1.

Ideally, I should define a new ThresholdRefiner that refine the union of two refining region
of two solution. This is not hard. But I am not sure how to do similarly for Derefiner.


3/25
fix a bug from boundary condition when compute J=nable Psi (it did not consider boundary condition)

3/23
clean up the explicit code; move on to test AMR (explicit)

Should I remove nodes in the mesh (nodes only for ALE type methods??)?

AMR with explicit time stepping is not very clear
How to do subcyling?


good example on amr:
 ./ex6 -m ../data/fichera.mesh -o 2

3/22 
After fix the rhs boundary bug, OK for wave case
tearing mode looks ok so far

exMHD -r 4 -tf 250 -vs 200 -dt .001 -i 2

3/21
o add visit

for o = 2
the solutions appear to be first order (from omega and phi); it looks okay
there is a boundary layer for omega

for o3 r4, the errors from boundary become very large; this is strange

Test:
exMHD -m ../xperiodic-square.mesh -r 2 -o 2 -tf 3 -vs 50 -dt .001 -visit
exMHD -m ../xperiodic-square.mesh -r 3 -o 2 -tf 3 -vs 100 -dt .0005 -visit

find a potential bug in the boundary: how could I impose dirichlet boundary in the right hand side?

redo those examples:
../exMHD -m ../xperiodic-square.mesh -r 2 -o 3 -tf 3 -vs 100 -dt .001 -visit
../exMHD -m ../xperiodic-square.mesh -r 3 -o 3 -tf 3 -vs 200 -dt .0005 -visit
../exMHD -m ../xperiodic-square.mesh -r 4 -o 3 -tf 3 -vs 400 -dt .00025 -visit


3/20
o fix a ploting issue for order>2
o fix the boundary orientation, I believe the normal has to be outward
o fix the time stepping
o add visual



3/19
the boundary seems working by using but I do not know why it works...

   const int dim=2;
   VectorArrayCoefficient force(dim);
   for (int i = 0; i < dim-1; i++)
   {
      force.Set(i, new ConstantCoefficient(0.0));
   }
   {
      Vector pull_force(fespace.GetMesh()->bdr_attributes.Max());
      pull_force = -1.0;
      force.Set(dim-1, new PWConstCoefficient(pull_force));
   }

   b.AddDomainIntegrator(new VectorBoundaryLFIntegrator(force));
   b.Assemble();

   K->FormLinearSystem(ess_tdof_list, psi, b, A, X, B);

   so I will subtract B from z.

>>>using this fix in the full code gives me errors associated with memory, I think I did something very crazy.

Tzanio sent me the working code. What is the difference between AddBdrFaceIntegrator and AddBoundaryIntegrator?


3/13
the explicit code is working, however (they are probably all related to the boundary)
the current is still not right,
the boundary condition is not right

note the boundary condition for current should be 0, which is wrong now
If I turned off background B/Phi, then the current solver is right!
Reason:
M*J=K*Psi; however J=0 along the boundary; K*Psi=Psi along the boundary which is inconsistent, I need subtract those off

Luis: if we can figure out how to do it matrix-free in the explicit scheme, we should be good for the implicit scheme. The only matrix that needs to assemble is the mass and stiffness matrix (once in the how solve)

Q:
what solvers for mass and stiffness matrices I am using?

2019/3/6
the stucture of explicit scheme seems clear
the linear parts seem ok
the nonlinear term requires some work:
1. for explicit scheme, it is okay: I need to update matrix inside time step (with proper assembling, I am still not sure about how to do it). both PDSolver and exMHD need some work.
2. for nonlinear problem, how could link nonlinear term properly??

2019/3/3
move back to MFEM

>>>plot solutions at each time step (see ex16)
first open a glvis as a server in another terminal
then run the program; it should plot results auto

11/1
some useful info for developer:
https://github.com/mfem/mfem/blob/master/CONTRIBUTING.md#code-overview

10/30/2018
I believe I could use FE solver by providing the right hand side in two updates

Then I could built right side separatedly
